Instructions for Prompt
- App purpose: a user can submit a simple form with to extract Telegram Groups (the user is admin or mamber) or Contacts (the user has in the Telegram Contacts or the user has a DM with)
- when you ask to create a new file always mention where (folder or root)
- we don't use Typescript but Javascript -js jsx json

Keep in mind:
- we are using Supabase, Vercel
- Supabase bases are set (users/Groups/Contacts)
- Vercel is set and ready to render any update
- for this MVP, we don't implement any login/auth logic yet
- it's an MVP so restrcited access to me and close friends to test
- We alsways must respect Telegram API TOS, rates and limitations: THIS IS CRUCIAL
- we are working on the MVP of my app 
- on a 'form' page the user can submit API ID, API Hash and Phone number 
- these details are used to call Telegram API to get corresponding records
- then the user selct Extract groups our Extract contacts
- then the user click on fetch data
- if the user has selected Extract groups after having clicked on Fetch Data: rediection to a new Page Groups List, where the user can select one, many or all groups and then the user can click on Download CSV - Then a CSV with selected records is generated
- if the user has selected Extract Contacts after having clicked on Fetch Data: rediection to a new Page Contacts List, where the user can select one, many or all contacts and then the user can click on Download CSV - Then a CSV with selected records is generated
- will will work doing short sprint (2/3h max per sprint)
__________________________________________________________________________________________________


Issues
- Issue #1: we will list issue we face here



How to solve
- Solution #1: we list there solutions we found

__________________________________________________________________________________________________


Daily Diary

Day 1: we will summarize each day whaat we have accomplished and and what need to be accomplished


__________________________________________________________________________________________________



**Dev Next steps**

1. Supabase Integration:
   * Supabase client setup: Already done in `supabase.js`.
   * Tables: Already created in Supabase.
   * Functions for data operations: Partially implemented in `main.py`, need to be adapted for client-side use.

2. Telegram API Integration:
   * API calls: Partially implemented in `main.py`, need to be moved to Next.js API routes.
   * Storing data in Supabase: Partially implemented in `main.py`.
   * TOS compliance: Needs verification and possibly adjustments.

3. Data Fetching and State Management:
   * We'll use React's built-in hooks (useState, useEffect) for state management and data fetching.
   * No need for additional libraries like SWR or React Query.

4. CSV Generation and Download:
   * Partially implemented in `main.py`, needs to be adapted for Next.js API routes.

5. UI Components and Responsiveness:
   * Mostly implemented with V0-generated code and improvements.
   * Loading states and success messages: Partially implemented, need some additions.

6. Error Handling and User Feedback:
   * Basic error handling implemented, needs enhancement.
   * User-friendly messages: Partially implemented, needs improvement.

7. Vercel Deployment and Environment Setup:
   * Already done.

8. Testing and Final Adjustments:
   * Still needed.

Updated Plan and Time Estimation:

1. Finalize Supabase Integration (1 hour)
   * Adapt data operation functions from `main.py` for client-side use in React components.

2. Complete Telegram API Integration (2-3 hours)
   * Move Telegram API calls from `main.py` to Next.js API routes.
   * Ensure proper data flow between Telegram API, Next.js API routes, and Supabase.
   * Verify and adjust for TOS compliance.

3. Enhance Data Fetching and State Management (1 hour)
   * Implement efficient data fetching from Supabase in React components.
   * Optimize state management using React hooks.

4. Finalize CSV Generation and Download (1 hour)
   * Adapt CSV generation logic for use in Next.js API route.
   * Implement client-side download functionality.

5. Polish UI and User Experience (1-2 hours)
   * Add any missing loading states and success messages.
   * Ensure responsiveness across different screen sizes.

6. Improve Error Handling and User Feedback (1 hour)
   * Enhance error handling for API calls and data operations.
   * Implement more user-friendly error messages and notifications.

7. Testing and Final Adjustments (2 hours)
   * Perform thorough manual testing of the entire flow.
   * Make necessary adjustments based on testing results.

Total revised estimated time: 9-11 hours

This plan takes into account the work that's already been done and focuses on adapting existing code to the Next.js and React environment, as well as finalizing features that are partially implemented. The reduced time estimate reflects the progress already made in various areas of the project.

__________________________________________________________________________________________________

Global Step-by-step plan with time estimations:

1. Update TelegramManager component (2 hours)
   - Modify the form submission to redirect to either the Groups List or Contacts List page based on the selected extract type.
   - Remove the group selection and extraction logic from this component.
   - Add state management (e.g., React Context or Redux) to store the API credentials and extract type for use in other components.

2. Create a new GroupsList component (3 hours)
   - Implement the layout and functionality as shown in the V0-generated code and screenshot.
   - Use the stored API credentials to fetch actual group data.
   - Implement the select all/unselect all functionality.
   - Add the "Extract Selected Groups" button that generates and downloads a CSV.

3. Create a new ContactsList component (3 hours)
   - Implement the layout and functionality as shown in the V0-generated code and screenshot.
   - Use the stored API credentials to fetch actual contact data.
   - Implement the select all/unselect all functionality.
   - Add the "Extract Selected Contacts" button that generates and downloads a CSV.

4. Update routing and navigation (1 hour)
   - Set up routes for the new GroupsList and ContactsList components.
   - Implement navigation between components.

5. Implement CSV generation and download functionality (2 hours)
   - Create a utility function to convert selected data to CSV format.
   - Implement the download mechanism for both groups and contacts.

6. Styling and UI polish (2 hours)
   - Ensure consistent styling across all components.
   - Implement responsive design for various screen sizes.

7. Error handling and user feedback (1 hour)
   - Add error messages for API failures or other issues.
   - Implement loading states and success messages.

8. Testing and bug fixing (2 hours)
   - Test the entire flow from start to finish.
   - Fix any bugs or issues discovered during testing.

Total estimated time: 16 hours

Here's a more detailed breakdown of the changes needed for each main component:



```jsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/router'
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { InfoIcon } from 'lucide-react'

export default function TelegramManager() {
  const [apiId, setApiId] = useState('')
  const [apiHash, setApiHash] = useState('')
  const [phoneNumber, setPhoneNumber] = useState('')
  const [extractType, setExtractType] = useState('groups')
  const [isLoading, setIsLoading] = useState(false)
  const router = useRouter()

  const handleSubmit = async (e) => {
    e.preventDefault()
    setIsLoading(true)
    
    // Here you would typically validate the input and make an API call
    // For now, we'll just simulate a delay and redirect
    await new Promise(resolve => setTimeout(resolve, 1000))
    
    // Store the credentials (in a real app, you'd use a more secure method)
    localStorage.setItem('telegramCredentials', JSON.stringify({ apiId, apiHash, phoneNumber }))
    
    // Redirect based on extract type
    if (extractType === 'groups') {
      router.push('/groups')
    } else {
      router.push('/contacts')
    }
    
    setIsLoading(false)
  }

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader>
        <CardTitle>Telegram Groups and Contacts Manager</CardTitle>
        <CardDescription>Manage your Telegram groups and contacts ethically</CardDescription>
      </CardHeader>
      <CardContent>
        <Alert className="mb-6">
          <InfoIcon className="h-4 w-4" />
          <AlertTitle>How to get API ID and API Hash</AlertTitle>
          <AlertDescription>
            {/* ... (keep the existing alert content) ... */}
          </AlertDescription>
        </Alert>
        <form onSubmit={handleSubmit} className="space-y-4">
          {/* ... (keep the existing form fields) ... */}
          <Button type="submit" disabled={isLoading}>
            {isLoading ? 'Loading...' : 'Fetch Data'}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}

```

Now, let's create the GroupsList component:



```jsx
'use client'

import { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { format } from 'date-fns'

export default function GroupsList() {
  const [groups, setGroups] = useState([])
  const [selectedGroups, setSelectedGroups] = useState([])
  const [selectAll, setSelectAll] = useState(false)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const fetchGroups = async () => {
      // Fetch the stored credentials
      const credentials = JSON.parse(localStorage.getItem('telegramCredentials'))
      
      // Here you would make an actual API call using the credentials
      // For now, we'll use mock data
      const mockGroups = [
        // ... (use the mock data from the V0-generated code)
      ]
      
      setGroups(mockGroups)
      setIsLoading(false)
    }

    fetchGroups()
  }, [])

  const handleSelectAll = () => {
    setSelectAll(!selectAll)
    setSelectedGroups(selectAll ? [] : groups.map(group => group.id))
  }

  const handleSelectGroup = (groupId) => {
    setSelectedGroups(prevSelected =>
      prevSelected.includes(groupId)
        ? prevSelected.filter(id => id !== groupId)
        : [...prevSelected, groupId]
    )
  }

  const handleExtract = () => {
    const selectedData = groups.filter(group => selectedGroups.includes(group.id))
    // Generate and download CSV
    // You'll need to implement this function
    generateAndDownloadCSV(selectedData, 'groups')
  }

  // ... (keep the formatRights function)

  return (
    <div className="container mx-auto py-10">
      {/* ... (implement the UI based on the V0-generated code and screenshot) ... */}
      <div className="mt-4">
        <Button onClick={handleExtract} disabled={selectedGroups.length === 0}>
          Extract Selected Groups
        </Button>
      </div>
    </div>
  )
}

```

Finally, let's create the ContactsList component:



```jsx
'use client'

import { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"

export default function ContactsList() {
  const [contacts, setContacts] = useState([])
  const [selectedContacts, setSelectedContacts] = useState([])
  const [selectAll, setSelectAll] = useState(false)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const fetchContacts = async () => {
      // Fetch the stored credentials
      const credentials = JSON.parse(localStorage.getItem('telegramCredentials'))
      
      // Here you would make an actual API call using the credentials
      // For now, we'll use mock data
      const mockContacts = [
        // ... (use the mock data from the V0-generated code)
      ]
      
      setContacts(mockContacts)
      setIsLoading(false)
    }

    fetchContacts()
  }, [])

  const handleSelectAll = () => {
    setSelectAll(!selectAll)
    setSelectedContacts(selectAll ? [] : contacts.map(contact => contact.id))
  }

  const handleSelectContact = (contactId) => {
    setSelectedContacts(prevSelected =>
      prevSelected.includes(contactId)
        ? prevSelected.filter(id => id !== contactId)
        : [...prevSelected, contactId]
    )
  }

  const handleExtract = () => {
    const selectedData = contacts.filter(contact => selectedContacts.includes(contact.id))
    // Generate and download CSV
    // You'll need to implement this function
    generateAndDownloadCSV(selectedData, 'contacts')
  }

  // ... (keep the getOnlineStatusColor function)

  return (
    <div className="container mx-auto py-10">
      {/* ... (implement the UI based on the V0-generated code and screenshot) ... */}
      <div className="mt-4">
        <Button onClick={handleExtract} disabled={selectedContacts.length === 0}>
          Extract Selected Contacts
        </Button>
      </div>
    </div>
  )
}

```

To complete the implementation, you'll need to:

1. Create a utility function for generating and downloading CSVs.
2. Set up proper routing in your Next.js application to handle navigation between these components.
3. Implement proper state management (e.g., React Context or Redux) to handle the storage and retrieval of API credentials more securely.
4. Add error handling and loading states throughout the application.
5. Ensure all UI components are properly styled and responsive.

This plan should give you a solid foundation for implementing the two-step process and updated designs you've described. The estimated 16 hours should be sufficient to complete these tasks, but actual time may vary depending on the complexity of your API integration and any additional features you may want to add.

Certainly! I'll provide a detailed step-by-step guide to implement the two-step approach for your Telegram Groups and Contacts Manager project. This guide will cover updating the existing files and creating new ones as needed.

Step 1: Update TelegramManager.jsx (2 hours)

1. Open TelegramManager.jsx
2. Replace the entire content with the following code:

```jsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/router'
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { InfoIcon } from 'lucide-react'

export default function TelegramManager() {
  const [apiId, setApiId] = useState('')
  const [apiHash, setApiHash] = useState('')
  const [phoneNumber, setPhoneNumber] = useState('')
  const [extractType, setExtractType] = useState('groups')
  const [isLoading, setIsLoading] = useState(false)
  const router = useRouter()

  const handleSubmit = async (e) => {
    e.preventDefault()
    setIsLoading(true)
    
    // Store the credentials (in a real app, you'd use a more secure method)
    localStorage.setItem('telegramCredentials', JSON.stringify({ apiId, apiHash, phoneNumber }))
    
    // Redirect based on extract type
    if (extractType === 'groups') {
      router.push('/groups')
    } else {
      router.push('/contacts')
    }
    
    setIsLoading(false)
  }

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader>
        <CardTitle>Telegram Groups and Contacts Manager</CardTitle>
        <CardDescription>Manage your Telegram groups and contacts ethically</CardDescription>
      </CardHeader>
      <CardContent>
        <Alert className="mb-6">
          <InfoIcon className="h-4 w-4" />
          <AlertTitle>How to get API ID and API Hash</AlertTitle>
          <AlertDescription>
            <ol className="list-decimal list-inside space-y-2">
              <li>Go to <a href="https://my.telegram.org" target="_blank" rel="noopener noreferrer" className="text-blue-500 hover:underline">https://my.telegram.org</a> and log in with your Telegram account.</li>
              <li>Click on 'API development tools'.</li>
              <li>Fill in the form with your app details.</li>
              <li>Click on 'Create application'.</li>
              <li>You'll see your API ID and API Hash on the next page. Use these in the form below.</li>
            </ol>
            <p className="mt-2"><strong>Note:</strong> Keep your API ID and API Hash private and never share them publicly.</p>
          </AlertDescription>
        </Alert>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="api-id">API ID</Label>
            <Input
              id="api-id"
              value={apiId}
              onChange={(e) => setApiId(e.target.value)}
              required
              placeholder="Enter your API ID"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="api-hash">API Hash</Label>
            <Input
              id="api-hash"
              value={apiHash}
              onChange={(e) => setApiHash(e.target.value)}
              required
              placeholder="Enter your API Hash"
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="phone-number">Phone Number</Label>
            <Input
              id="phone-number"
              value={phoneNumber}
              onChange={(e) => setPhoneNumber(e.target.value)}
              required
              placeholder="Enter your phone number (with country code)"
            />
          </div>
          <RadioGroup value={extractType} onValueChange={setExtractType}>
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="groups" id="groups" />
              <Label htmlFor="groups">Extract Groups</Label>
            </div>
            <div className="flex items-center space-x-2">
              <RadioGroupItem value="contacts" id="contacts" />
              <Label htmlFor="contacts">Extract Contacts</Label>
            </div>
          </RadioGroup>
          <Button type="submit" disabled={isLoading}>
            {isLoading ? 'Loading...' : 'Fetch Data'}
          </Button>
        </form>
      </CardContent>
    </Card>
  )
}

```

Step 2: Update page.js or index.js (30 minutes)

1. Open your main page file (either page.js or index.js, depending on your Next.js setup)
2. Update the content to use the TelegramManager component:

```jsx
import TelegramManager from '@/components/TelegramManager'

export default function Home() {
  return (
    <div className="container mx-auto py-10">
      <h1 className="text-3xl font-bold mb-6 text-center">Telegram Groups and Contacts Extractor</h1>
      <p className="text-center text-lg mb-10">
        Easily manage and extract data from your Telegram groups and contacts.
      </p>
      <TelegramManager />
    </div>
  )
}

```

Step 3: Create GroupsList.jsx (3 hours)

1. Create a new file called GroupsList.jsx in your components folder
2. Add the following code:

```jsx
'use client'

import { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { format } from 'date-fns'

export default function GroupsList() {
  const [groups, setGroups] = useState([])
  const [selectedGroups, setSelectedGroups] = useState([])
  const [selectAll, setSelectAll] = useState(false)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const fetchGroups = async () => {
      const credentials = JSON.parse(localStorage.getItem('telegramCredentials'))
      
      // TODO: Replace this with actual API call
      const mockGroups = [
        {
          id: 1,
          title: "Tech Enthusiasts",
          description: "A group for discussing the latest in technology",
          inviteLink: "https://t.me/techenthusiasts",
          participantCount: 500,
          creationDate: "2023-01-15T12:00:00Z",
          isSupergroup: true,
          isChannel: false,
          adminRights: ["delete_messages", "ban_users"],
          bannedRights: ["send_media"]
        },
        // Add more mock groups as needed
      ]
      
      setGroups(mockGroups)
      setIsLoading(false)
    }

    fetchGroups()
  }, [])

  const handleSelectAll = () => {
    setSelectAll(!selectAll)
    setSelectedGroups(selectAll ? [] : groups.map(group => group.id))
  }

  const handleSelectGroup = (groupId) => {
    setSelectedGroups(prevSelected =>
      prevSelected.includes(groupId)
        ? prevSelected.filter(id => id !== groupId)
        : [...prevSelected, groupId]
    )
  }

  const handleExtract = () => {
    const selectedData = groups.filter(group => selectedGroups.includes(group.id))
    // TODO: Implement CSV generation and download
    console.log("Extracting:", selectedData)
  }

  const formatRights = (rights) => rights.join(", ") || "None"

  return (
    <div className="container mx-auto py-10">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-bold">Groups List</h2>
        <div className="flex items-center space-x-2">
          <Checkbox
            id="select-all"
            checked={selectAll}
            onCheckedChange={handleSelectAll}
          />
          <label htmlFor="select-all" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
            {selectAll ? "Unselect All" : "Select All"}
          </label>
        </div>
      </div>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[50px]">Select</TableHead>
              <TableHead>Group Name</TableHead>
              <TableHead>Group ID</TableHead>
              <TableHead>Description</TableHead>
              <TableHead>Invite Link</TableHead>
              <TableHead>Participants</TableHead>
              <TableHead>Created</TableHead>
              <TableHead>Type</TableHead>
              <TableHead>Admin Rights</TableHead>
              <TableHead>Banned Rights</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {groups.map((group) => (
              <TableRow key={group.id}>
                <TableCell>
                  <Checkbox
                    checked={selectedGroups.includes(group.id)}
                    onCheckedChange={() => handleSelectGroup(group.id)}
                  />
                </TableCell>
                <TableCell className="font-medium">{group.title}</TableCell>
                <TableCell>{group.id}</TableCell>
                <TableCell>{group.description}</TableCell>
                <TableCell>
                  <a href={group.inviteLink} target="_blank" rel="noopener noreferrer" className="text-blue-500 hover:underline">
                    {group.inviteLink}
                  </a>
                </TableCell>
                <TableCell>{group.participantCount}</TableCell>
                <TableCell>{format(new Date(group.creationDate), 'PPP')}</TableCell>
                <TableCell>
                  {group.isSupergroup ? "Supergroup" : group.isChannel ? "Channel" : "Group"}
                </TableCell>
                <TableCell>{formatRights(group.adminRights)}</TableCell>
                <TableCell>{formatRights(group.bannedRights)}</TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
      <div className="mt-4">
        <Button onClick={handleExtract} disabled={selectedGroups.length === 0}>
          Extract Selected Groups
        </Button>
      </div>
    </div>
  )
}

```

Step 4: Create ContactsList.jsx (3 hours)

1. Create a new file called ContactsList.jsx in your components folder
2. Add the following code:

```jsx
'use client'

import { useState, useEffect } from 'react'
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Badge } from "@/components/ui/badge"

export default function ContactsList() {
  const [contacts, setContacts] = useState([])
  const [selectedContacts, setSelectedContacts] = useState([])
  const [selectAll, setSelectAll] = useState(false)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const fetchContacts = async () => {
      const credentials = JSON.parse(localStorage.getItem('telegramCredentials'))
      
      // TODO: Replace this with actual API call
      const mockContacts = [
        {
          id: 1,
          firstName: "John",
          lastName: "Doe",
          username: "johndoe",
          phoneNumber: "+1234567890",
          bio: "Tech enthusiast and coffee lover",
          photoUrl: "/placeholder.svg?height=40&width=40",
          onlineStatus: 'online',
          isBot: false
        },
        // Add more mock contacts as needed
      ]
      
      setContacts(mockContacts)
      setIsLoading(false)
    }

    fetchContacts()
  }, [])

  const handleSelectAll = () => {
    setSelectAll(!selectAll)
    setSelectedContacts(selectAll ? [] : contacts.map(contact => contact.id))
  }

  const handleSelectContact = (contactId) => {
    setSelectedContacts(prevSelected =>
      prevSelected.includes(contactId)
        ? prevSelected.filter(id => id !== contactId)
        : [...prevSelected, contactId]
    )
  }

  const handleExtract = () => {
    const selectedData = contacts.filter(contact => selectedContacts.includes(contact.id))
    // TODO: Implement CSV generation and download
    console.log("Extracting:", selectedData)
  }

  const getOnlineStatusColor = (status) => {
    switch (status) {
      case 'online': return 'bg-green-500'
      case 'recently': return 'bg-yellow-500'
      default: return 'bg-gray-500'
    }
  }

  return (
    <div className="container mx-auto py-10">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-2xl font-bold">Contacts List</h2>
        <div className="flex items-center space-x-2">
          <Checkbox
            id="select-all"
            checked={selectAll}
            onCheckedChange={handleSelectAll}
          />
          <label htmlFor="select-all" className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70">
            {selectAll ? "Unselect All" : "Select All"}
          </label>
        </div>
      </div>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[50px]">Select</TableHead>
              <TableHead>User ID</TableHead>
              <TableHead>Name</TableHead>
              <TableHead>Username</TableHead>
              <TableHead>Phone Number</TableHead>
              <TableHead>Bio</TableHead>
              <TableHead>Profile Photo</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Bot</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {contacts.map((contact) => (
              <TableRow key={contact.id}>
                <TableCell>
                  <Checkbox
                    checked={selectedContacts.includes(contact.id)}
                    onCheckedChange={() => handleSelectContact(contact.id)}
                  />
                </TableCell>
                <TableCell>{contact.id}</TableCell
```